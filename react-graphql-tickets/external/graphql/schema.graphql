"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

input AuthProviderCredentialsInput {
  email: String!
  password: String!
}

"""Autogenerated return type of CreateOrder"""
type CreateOrderPayload {
  receipt: Receipt!
}

"""Autogenerated return type of CreatePerformance"""
type CreatePerformancePayload {
  performance: Performance!
  production: Production!
}

type Customer {
  email: String
  id: ID!
  name: String
  receipts: [Receipt!]
  user: User
}

"""The connection type for Customer."""
type CustomerConnection {
  """A list of edges."""
  edges: [CustomerEdge]

  """A list of nodes."""
  nodes: [Customer]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type CustomerConnectionWrapper {
  customers(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): CustomerConnection!
}

"""An edge in a connection."""
type CustomerEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Customer
}

input CustomerSearchInput {
  query: String
  ids: [ID!]
}

"""An ISO 8601-encoded datetime"""
scalar ISO8601DateTime

type Mutation {
  createOrder: CreateOrderPayload
  createPerformance(productionId: ID!, performance: PerformanceInput!): CreatePerformancePayload
  signInUser(credentials: AuthProviderCredentialsInput): SignInUserPayload
  updateOrder(receiptId: ID!, update: UpdateOrderInput!): UpdateOrderPayload
}

type Organization {
  createdAt: ISO8601DateTime!
  customerSearch(input: CustomerSearchInput!): CustomerConnectionWrapper!
  customers(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): CustomerConnection!
  id: ID!
  name: String
  productions: [Production!]!
  updatedAt: ISO8601DateTime!
  users: [User!]!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type Performance {
  createdAt: ISO8601DateTime!
  doorsOpenAt: ISO8601DateTime
  id: ID!
  name: String
  production: Production!
  showtimeAt: ISO8601DateTime
  updatedAt: ISO8601DateTime!
}

input PerformanceInput {
  name: String
  showtimeAt: ISO8601DateTime!
  doorsOpenAt: ISO8601DateTime
}

type PerformanceOrderForm {
  organization: Organization!
  performance: Performance!
  production: Production!
  receipt: Receipt!
  ticketTypes: [TicketType!]!
}

type Production {
  createdAt: ISO8601DateTime!
  id: ID!
  organization: Organization!
  performanceCount: Int!
  performances: [Performance!]
  runtimeMinutes: Int
  ticketTypes: [TicketType!]
  title: String
  updatedAt: ISO8601DateTime!
}

type Query {
  """Current user"""
  currentUser: User
  draftReceipt: Receipt

  """A single organization"""
  organization(id: ID!): Organization!

  """All organizations"""
  organizations: [Organization!]

  """Performance order form fields"""
  performanceOrderForm(id: ID!): PerformanceOrderForm

  """A single production"""
  production(organizationId: ID!, id: ID!): Production!
}

type Receipt {
  aasmState: String!
  customer: Customer!
  id: ID!
  tickets: [Ticket!]!
}

"""Autogenerated return type of SignInUser"""
type SignInUserPayload {
  token: String
  user: User
}

type Ticket {
  id: ID!
  performance: Performance!
  ticketType: TicketType!
}

type TicketType {
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  priceInCents: Int!
  production: Production!
  updatedAt: ISO8601DateTime!
}

input TicketTypeQuantityInput {
  ticketTypeId: ID!
  quantity: Int!
}

input UpdateOrderInput {
  ticketTypeQuantities: [TicketTypeQuantityInput!]!
  performanceId: ID!
}

"""Autogenerated return type of UpdateOrder"""
type UpdateOrderPayload {
  receipt: Receipt!
}

type User {
  createdAt: ISO8601DateTime!
  email: String
  id: ID!
  name: String
  organizationId: Int!
  updatedAt: ISO8601DateTime!
}
